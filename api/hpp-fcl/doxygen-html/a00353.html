<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>traversal_node_setup.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
</head><body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_bb90483854b6bde7e2e1c48d4231685b.html">include</a></li><li class="navelem"><a class="el" href="dir_6dc4bc67e1ce873d2865f9beb739e105.html">hpp</a></li><li class="navelem"><a class="el" href="dir_20fa1abcad33804f5539e29af8f8ee4c.html">fcl</a></li><li class="navelem"><a class="el" href="dir_35faeb12b5846e0072da59833a7dc403.html">traversal</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">traversal_node_setup.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;hpp/fcl/config-fcl.hh&gt;</code><br />
<code>#include &lt;<a class="el" href="a00351.html">hpp/fcl/traversal/traversal_node_bvhs.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="a00354.html">hpp/fcl/traversal/traversal_node_shapes.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="a00350.html">hpp/fcl/traversal/traversal_node_bvh_shape.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="a00352.html">hpp/fcl/traversal/traversal_node_octree.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="a00274.html">hpp/fcl/BVH/BVH_utility.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for traversal_node_setup.h:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00528.svg" width="2746" height="896"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:a00314"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00314.html">fcl</a></td></tr>
<tr class="memdesc:a00314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00362"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00362.html">fcl::details</a></td></tr>
<tr class="memdesc:a00362"><td class="mdescLeft">&#160;</td><td class="mdescRight">FCL internals. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a95c64c901cb6f88eb8f1750a3a39693b"><td class="memTemplParams" colspan="2">template&lt;typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a95c64c901cb6f88eb8f1750a3a39693b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a95c64c901cb6f88eb8f1750a3a39693b">fcl::initialize</a> (OcTreeCollisionTraversalNode&lt; NarrowPhaseSolver &gt; &amp;node, const OcTree &amp;model1, const Transform3f &amp;tf1, const OcTree &amp;model2, const Transform3f &amp;tf2, const OcTreeSolver&lt; NarrowPhaseSolver &gt; *otsolver, const CollisionRequest &amp;request, CollisionResult &amp;result)</td></tr>
<tr class="memdesc:a95c64c901cb6f88eb8f1750a3a39693b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for collision between two octrees, given current object transform.  <a href="a00314.html#a95c64c901cb6f88eb8f1750a3a39693b">More...</a><br /></td></tr>
<tr class="separator:a95c64c901cb6f88eb8f1750a3a39693b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecc8f3c7a74fb248281752df1057821"><td class="memTemplParams" colspan="2">template&lt;typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:abecc8f3c7a74fb248281752df1057821"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#abecc8f3c7a74fb248281752df1057821">fcl::initialize</a> (OcTreeDistanceTraversalNode&lt; NarrowPhaseSolver &gt; &amp;node, const OcTree &amp;model1, const Transform3f &amp;tf1, const OcTree &amp;model2, const Transform3f &amp;tf2, const OcTreeSolver&lt; NarrowPhaseSolver &gt; *otsolver, const DistanceRequest &amp;request, DistanceResult &amp;result)</td></tr>
<tr class="memdesc:abecc8f3c7a74fb248281752df1057821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for distance between two octrees, given current object transform.  <a href="a00314.html#abecc8f3c7a74fb248281752df1057821">More...</a><br /></td></tr>
<tr class="separator:abecc8f3c7a74fb248281752df1057821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67080379fadfd9c25d38e7ea1abf3a30"><td class="memTemplParams" colspan="2">template&lt;typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a67080379fadfd9c25d38e7ea1abf3a30"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a67080379fadfd9c25d38e7ea1abf3a30">fcl::initialize</a> (ShapeOcTreeCollisionTraversalNode&lt; S, NarrowPhaseSolver &gt; &amp;node, const S &amp;model1, const Transform3f &amp;tf1, const OcTree &amp;model2, const Transform3f &amp;tf2, const OcTreeSolver&lt; NarrowPhaseSolver &gt; *otsolver, const CollisionRequest &amp;request, CollisionResult &amp;result)</td></tr>
<tr class="memdesc:a67080379fadfd9c25d38e7ea1abf3a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for collision between one shape and one octree, given current object transform.  <a href="a00314.html#a67080379fadfd9c25d38e7ea1abf3a30">More...</a><br /></td></tr>
<tr class="separator:a67080379fadfd9c25d38e7ea1abf3a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f505723cb795ddf80392e80a683edec"><td class="memTemplParams" colspan="2">template&lt;typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a1f505723cb795ddf80392e80a683edec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a1f505723cb795ddf80392e80a683edec">fcl::initialize</a> (OcTreeShapeCollisionTraversalNode&lt; S, NarrowPhaseSolver &gt; &amp;node, const OcTree &amp;model1, const Transform3f &amp;tf1, const S &amp;model2, const Transform3f &amp;tf2, const OcTreeSolver&lt; NarrowPhaseSolver &gt; *otsolver, const CollisionRequest &amp;request, CollisionResult &amp;result)</td></tr>
<tr class="memdesc:a1f505723cb795ddf80392e80a683edec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for collision between one octree and one shape, given current object transform.  <a href="a00314.html#a1f505723cb795ddf80392e80a683edec">More...</a><br /></td></tr>
<tr class="separator:a1f505723cb795ddf80392e80a683edec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae237616b7df4d8c8ee98326920665189"><td class="memTemplParams" colspan="2">template&lt;typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:ae237616b7df4d8c8ee98326920665189"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#ae237616b7df4d8c8ee98326920665189">fcl::initialize</a> (ShapeOcTreeDistanceTraversalNode&lt; S, NarrowPhaseSolver &gt; &amp;node, const S &amp;model1, const Transform3f &amp;tf1, const OcTree &amp;model2, const Transform3f &amp;tf2, const OcTreeSolver&lt; NarrowPhaseSolver &gt; *otsolver, const DistanceRequest &amp;request, DistanceResult &amp;result)</td></tr>
<tr class="memdesc:ae237616b7df4d8c8ee98326920665189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for distance between one shape and one octree, given current object transform.  <a href="a00314.html#ae237616b7df4d8c8ee98326920665189">More...</a><br /></td></tr>
<tr class="separator:ae237616b7df4d8c8ee98326920665189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c81924d79340eb18d2575fd1827c631"><td class="memTemplParams" colspan="2">template&lt;typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a3c81924d79340eb18d2575fd1827c631"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a3c81924d79340eb18d2575fd1827c631">fcl::initialize</a> (OcTreeShapeDistanceTraversalNode&lt; S, NarrowPhaseSolver &gt; &amp;node, const OcTree &amp;model1, const Transform3f &amp;tf1, const S &amp;model2, const Transform3f &amp;tf2, const OcTreeSolver&lt; NarrowPhaseSolver &gt; *otsolver, const DistanceRequest &amp;request, DistanceResult &amp;result)</td></tr>
<tr class="memdesc:a3c81924d79340eb18d2575fd1827c631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for distance between one octree and one shape, given current object transform.  <a href="a00314.html#a3c81924d79340eb18d2575fd1827c631">More...</a><br /></td></tr>
<tr class="separator:a3c81924d79340eb18d2575fd1827c631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a08f56435bc4aae04b02f5f709fd7e7"><td class="memTemplParams" colspan="2">template&lt;typename BV , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a8a08f56435bc4aae04b02f5f709fd7e7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a8a08f56435bc4aae04b02f5f709fd7e7">fcl::initialize</a> (MeshOcTreeCollisionTraversalNode&lt; BV, NarrowPhaseSolver &gt; &amp;node, const BVHModel&lt; BV &gt; &amp;model1, const Transform3f &amp;tf1, const OcTree &amp;model2, const Transform3f &amp;tf2, const OcTreeSolver&lt; NarrowPhaseSolver &gt; *otsolver, const CollisionRequest &amp;request, CollisionResult &amp;result)</td></tr>
<tr class="memdesc:a8a08f56435bc4aae04b02f5f709fd7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for collision between one mesh and one octree, given current object transform.  <a href="a00314.html#a8a08f56435bc4aae04b02f5f709fd7e7">More...</a><br /></td></tr>
<tr class="separator:a8a08f56435bc4aae04b02f5f709fd7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80aa9d05e2f6d5e36e8ebc3f05872b9c"><td class="memTemplParams" colspan="2">template&lt;typename BV , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a80aa9d05e2f6d5e36e8ebc3f05872b9c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a80aa9d05e2f6d5e36e8ebc3f05872b9c">fcl::initialize</a> (OcTreeMeshCollisionTraversalNode&lt; BV, NarrowPhaseSolver &gt; &amp;node, const OcTree &amp;model1, const Transform3f &amp;tf1, const BVHModel&lt; BV &gt; &amp;model2, const Transform3f &amp;tf2, const OcTreeSolver&lt; NarrowPhaseSolver &gt; *otsolver, const CollisionRequest &amp;request, CollisionResult &amp;result)</td></tr>
<tr class="memdesc:a80aa9d05e2f6d5e36e8ebc3f05872b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for collision between one octree and one mesh, given current object transform.  <a href="a00314.html#a80aa9d05e2f6d5e36e8ebc3f05872b9c">More...</a><br /></td></tr>
<tr class="separator:a80aa9d05e2f6d5e36e8ebc3f05872b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058e2b263abb136da7805bd08e824d85"><td class="memTemplParams" colspan="2">template&lt;typename BV , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a058e2b263abb136da7805bd08e824d85"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a058e2b263abb136da7805bd08e824d85">fcl::initialize</a> (MeshOcTreeDistanceTraversalNode&lt; BV, NarrowPhaseSolver &gt; &amp;node, const BVHModel&lt; BV &gt; &amp;model1, const Transform3f &amp;tf1, const OcTree &amp;model2, const Transform3f &amp;tf2, const OcTreeSolver&lt; NarrowPhaseSolver &gt; *otsolver, const DistanceRequest &amp;request, DistanceResult &amp;result)</td></tr>
<tr class="memdesc:a058e2b263abb136da7805bd08e824d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for distance between one mesh and one octree, given current object transform.  <a href="a00314.html#a058e2b263abb136da7805bd08e824d85">More...</a><br /></td></tr>
<tr class="separator:a058e2b263abb136da7805bd08e824d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae758c19a134b952324cd3ccee901008b"><td class="memTemplParams" colspan="2">template&lt;typename BV , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:ae758c19a134b952324cd3ccee901008b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#ae758c19a134b952324cd3ccee901008b">fcl::initialize</a> (OcTreeMeshDistanceTraversalNode&lt; BV, NarrowPhaseSolver &gt; &amp;node, const OcTree &amp;model1, const Transform3f &amp;tf1, const BVHModel&lt; BV &gt; &amp;model2, const Transform3f &amp;tf2, const OcTreeSolver&lt; NarrowPhaseSolver &gt; *otsolver, const DistanceRequest &amp;request, DistanceResult &amp;result)</td></tr>
<tr class="memdesc:ae758c19a134b952324cd3ccee901008b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for collision between one octree and one mesh, given current object transform.  <a href="a00314.html#ae758c19a134b952324cd3ccee901008b">More...</a><br /></td></tr>
<tr class="separator:ae758c19a134b952324cd3ccee901008b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd607b020cf207eab8f10c138617c13a"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:acd607b020cf207eab8f10c138617c13a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#acd607b020cf207eab8f10c138617c13a">fcl::initialize</a> (ShapeCollisionTraversalNode&lt; S1, S2, NarrowPhaseSolver &gt; &amp;node, const S1 &amp;shape1, const Transform3f &amp;tf1, const S2 &amp;shape2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, const CollisionRequest &amp;request, CollisionResult &amp;result)</td></tr>
<tr class="memdesc:acd607b020cf207eab8f10c138617c13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for collision between two geometric shapes, given current object transform.  <a href="a00314.html#acd607b020cf207eab8f10c138617c13a">More...</a><br /></td></tr>
<tr class="separator:acd607b020cf207eab8f10c138617c13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa865edb51f351bf334de5abaf49eb26b"><td class="memTemplParams" colspan="2">template&lt;typename BV , typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:aa865edb51f351bf334de5abaf49eb26b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#aa865edb51f351bf334de5abaf49eb26b">fcl::initialize</a> (MeshShapeCollisionTraversalNode&lt; BV, S, NarrowPhaseSolver &gt; &amp;node, BVHModel&lt; BV &gt; &amp;model1, Transform3f &amp;tf1, const S &amp;model2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, const CollisionRequest &amp;request, CollisionResult &amp;result, bool use_refit=false, bool refit_bottomup=false)</td></tr>
<tr class="memdesc:aa865edb51f351bf334de5abaf49eb26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for collision between one mesh and one shape, given current object transform.  <a href="a00314.html#aa865edb51f351bf334de5abaf49eb26b">More...</a><br /></td></tr>
<tr class="separator:aa865edb51f351bf334de5abaf49eb26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588a866a35e1c184f67b431a3078bdd9"><td class="memTemplParams" colspan="2">template&lt;typename S , typename BV , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a588a866a35e1c184f67b431a3078bdd9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a588a866a35e1c184f67b431a3078bdd9">fcl::initialize</a> (ShapeMeshCollisionTraversalNode&lt; S, BV, NarrowPhaseSolver &gt; &amp;node, const S &amp;model1, const Transform3f &amp;tf1, BVHModel&lt; BV &gt; &amp;model2, Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, const CollisionRequest &amp;request, CollisionResult &amp;result, bool use_refit=false, bool refit_bottomup=false)</td></tr>
<tr class="memdesc:a588a866a35e1c184f67b431a3078bdd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for collision between one mesh and one shape, given current object transform.  <a href="a00314.html#a588a866a35e1c184f67b431a3078bdd9">More...</a><br /></td></tr>
<tr class="separator:a588a866a35e1c184f67b431a3078bdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f5e9ecb6e66b9fcd67cab7cddbe5bf"><td class="memTemplParams" colspan="2">template&lt;typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:ab3f5e9ecb6e66b9fcd67cab7cddbe5bf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#ab3f5e9ecb6e66b9fcd67cab7cddbe5bf">fcl::initialize</a> (MeshShapeCollisionTraversalNodeOBB&lt; S, NarrowPhaseSolver &gt; &amp;node, const BVHModel&lt; OBB &gt; &amp;model1, const Transform3f &amp;tf1, const S &amp;model2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, const CollisionRequest &amp;request, CollisionResult &amp;result)</td></tr>
<tr class="memdesc:ab3f5e9ecb6e66b9fcd67cab7cddbe5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the traversal node for collision between one mesh and one shape, specialized for <a class="el" href="a00154.html" title="Oriented bounding box class. ">OBB</a> type.  <a href="a00314.html#ab3f5e9ecb6e66b9fcd67cab7cddbe5bf">More...</a><br /></td></tr>
<tr class="separator:ab3f5e9ecb6e66b9fcd67cab7cddbe5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b5d7b8983d01fba523c93a8bc2a380"><td class="memTemplParams" colspan="2">template&lt;typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:ad1b5d7b8983d01fba523c93a8bc2a380"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#ad1b5d7b8983d01fba523c93a8bc2a380">fcl::initialize</a> (MeshShapeCollisionTraversalNodeRSS&lt; S, NarrowPhaseSolver &gt; &amp;node, const BVHModel&lt; RSS &gt; &amp;model1, const Transform3f &amp;tf1, const S &amp;model2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, const CollisionRequest &amp;request, CollisionResult &amp;result)</td></tr>
<tr class="memdesc:ad1b5d7b8983d01fba523c93a8bc2a380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the traversal node for collision between one mesh and one shape, specialized for <a class="el" href="a00181.html" title="A class for rectangle sphere-swept bounding volume. ">RSS</a> type.  <a href="a00314.html#ad1b5d7b8983d01fba523c93a8bc2a380">More...</a><br /></td></tr>
<tr class="separator:ad1b5d7b8983d01fba523c93a8bc2a380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ffc35029b19cd0acaac3f2135ad185c"><td class="memTemplParams" colspan="2">template&lt;typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a8ffc35029b19cd0acaac3f2135ad185c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a8ffc35029b19cd0acaac3f2135ad185c">fcl::initialize</a> (MeshShapeCollisionTraversalNodekIOS&lt; S, NarrowPhaseSolver &gt; &amp;node, const BVHModel&lt; kIOS &gt; &amp;model1, const Transform3f &amp;tf1, const S &amp;model2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, const CollisionRequest &amp;request, CollisionResult &amp;result)</td></tr>
<tr class="memdesc:a8ffc35029b19cd0acaac3f2135ad185c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the traversal node for collision between one mesh and one shape, specialized for <a class="el" href="a00105.html" title="A class describing the kIOS collision structure, which is a set of spheres. ">kIOS</a> type.  <a href="a00314.html#a8ffc35029b19cd0acaac3f2135ad185c">More...</a><br /></td></tr>
<tr class="separator:a8ffc35029b19cd0acaac3f2135ad185c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdc86d927f2b364ccfc40f1bbf141cc"><td class="memTemplParams" colspan="2">template&lt;typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a5fdc86d927f2b364ccfc40f1bbf141cc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a5fdc86d927f2b364ccfc40f1bbf141cc">fcl::initialize</a> (MeshShapeCollisionTraversalNodeOBBRSS&lt; S, NarrowPhaseSolver &gt; &amp;node, const BVHModel&lt; OBBRSS &gt; &amp;model1, const Transform3f &amp;tf1, const S &amp;model2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, const CollisionRequest &amp;request, CollisionResult &amp;result)</td></tr>
<tr class="memdesc:a5fdc86d927f2b364ccfc40f1bbf141cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the traversal node for collision between one mesh and one shape, specialized for <a class="el" href="a00155.html" title="Class merging the OBB and RSS, can handle collision and distance simultaneously. ">OBBRSS</a> type.  <a href="a00314.html#a5fdc86d927f2b364ccfc40f1bbf141cc">More...</a><br /></td></tr>
<tr class="separator:a5fdc86d927f2b364ccfc40f1bbf141cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea460cfebe54203d1954be60a1bb5b2"><td class="memTemplParams" colspan="2">template&lt;typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:abea460cfebe54203d1954be60a1bb5b2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#abea460cfebe54203d1954be60a1bb5b2">fcl::initialize</a> (ShapeMeshCollisionTraversalNodeOBB&lt; S, NarrowPhaseSolver &gt; &amp;node, const S &amp;model1, const Transform3f &amp;tf1, const BVHModel&lt; OBB &gt; &amp;model2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, const CollisionRequest &amp;request, CollisionResult &amp;result)</td></tr>
<tr class="memdesc:abea460cfebe54203d1954be60a1bb5b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the traversal node for collision between one mesh and one shape, specialized for <a class="el" href="a00154.html" title="Oriented bounding box class. ">OBB</a> type.  <a href="a00314.html#abea460cfebe54203d1954be60a1bb5b2">More...</a><br /></td></tr>
<tr class="separator:abea460cfebe54203d1954be60a1bb5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3624c11d42574422bface52f58c83d4f"><td class="memTemplParams" colspan="2">template&lt;typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a3624c11d42574422bface52f58c83d4f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a3624c11d42574422bface52f58c83d4f">fcl::initialize</a> (ShapeMeshCollisionTraversalNodeRSS&lt; S, NarrowPhaseSolver &gt; &amp;node, const S &amp;model1, const Transform3f &amp;tf1, const BVHModel&lt; RSS &gt; &amp;model2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, const CollisionRequest &amp;request, CollisionResult &amp;result)</td></tr>
<tr class="memdesc:a3624c11d42574422bface52f58c83d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the traversal node for collision between one mesh and one shape, specialized for <a class="el" href="a00181.html" title="A class for rectangle sphere-swept bounding volume. ">RSS</a> type.  <a href="a00314.html#a3624c11d42574422bface52f58c83d4f">More...</a><br /></td></tr>
<tr class="separator:a3624c11d42574422bface52f58c83d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa452c35c4e98705c65b40d562a3732"><td class="memTemplParams" colspan="2">template&lt;typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a5fa452c35c4e98705c65b40d562a3732"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a5fa452c35c4e98705c65b40d562a3732">fcl::initialize</a> (ShapeMeshCollisionTraversalNodekIOS&lt; S, NarrowPhaseSolver &gt; &amp;node, const S &amp;model1, const Transform3f &amp;tf1, const BVHModel&lt; kIOS &gt; &amp;model2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, const CollisionRequest &amp;request, CollisionResult &amp;result)</td></tr>
<tr class="memdesc:a5fa452c35c4e98705c65b40d562a3732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the traversal node for collision between one mesh and one shape, specialized for <a class="el" href="a00105.html" title="A class describing the kIOS collision structure, which is a set of spheres. ">kIOS</a> type.  <a href="a00314.html#a5fa452c35c4e98705c65b40d562a3732">More...</a><br /></td></tr>
<tr class="separator:a5fa452c35c4e98705c65b40d562a3732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2bf8dd51936181b642b18143ee72d18"><td class="memTemplParams" colspan="2">template&lt;typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:ac2bf8dd51936181b642b18143ee72d18"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#ac2bf8dd51936181b642b18143ee72d18">fcl::initialize</a> (ShapeMeshCollisionTraversalNodeOBBRSS&lt; S, NarrowPhaseSolver &gt; &amp;node, const S &amp;model1, const Transform3f &amp;tf1, const BVHModel&lt; OBBRSS &gt; &amp;model2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, const CollisionRequest &amp;request, CollisionResult &amp;result)</td></tr>
<tr class="memdesc:ac2bf8dd51936181b642b18143ee72d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the traversal node for collision between one mesh and one shape, specialized for <a class="el" href="a00155.html" title="Class merging the OBB and RSS, can handle collision and distance simultaneously. ">OBBRSS</a> type.  <a href="a00314.html#ac2bf8dd51936181b642b18143ee72d18">More...</a><br /></td></tr>
<tr class="separator:ac2bf8dd51936181b642b18143ee72d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138dceb59bc0f4683725b9744958566d"><td class="memTemplParams" colspan="2">template&lt;typename BV &gt; </td></tr>
<tr class="memitem:a138dceb59bc0f4683725b9744958566d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a138dceb59bc0f4683725b9744958566d">fcl::initialize</a> (MeshCollisionTraversalNode&lt; BV &gt; &amp;node, BVHModel&lt; BV &gt; &amp;model1, Transform3f &amp;tf1, BVHModel&lt; BV &gt; &amp;model2, Transform3f &amp;tf2, const CollisionRequest &amp;request, CollisionResult &amp;result, bool use_refit=false, bool refit_bottomup=false)</td></tr>
<tr class="memdesc:a138dceb59bc0f4683725b9744958566d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for collision between two meshes, given the current transforms.  <a href="a00314.html#a138dceb59bc0f4683725b9744958566d">More...</a><br /></td></tr>
<tr class="separator:a138dceb59bc0f4683725b9744958566d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69c5d93b0946b5e52c1090d9ff54138"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00314.html#ad69c5d93b0946b5e52c1090d9ff54138">fcl::initialize</a> (MeshCollisionTraversalNodeOBB &amp;node, const BVHModel&lt; OBB &gt; &amp;model1, const Transform3f &amp;tf1, const BVHModel&lt; OBB &gt; &amp;model2, const Transform3f &amp;tf2, const CollisionRequest &amp;request, CollisionResult &amp;result)</td></tr>
<tr class="memdesc:ad69c5d93b0946b5e52c1090d9ff54138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for collision between two meshes, specialized for <a class="el" href="a00154.html" title="Oriented bounding box class. ">OBB</a> type.  <a href="a00314.html#ad69c5d93b0946b5e52c1090d9ff54138">More...</a><br /></td></tr>
<tr class="separator:ad69c5d93b0946b5e52c1090d9ff54138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6172ba73edad2b47579add3a42420f13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00314.html#a6172ba73edad2b47579add3a42420f13">fcl::initialize</a> (MeshCollisionTraversalNodeRSS &amp;node, const BVHModel&lt; RSS &gt; &amp;model1, const Transform3f &amp;tf1, const BVHModel&lt; RSS &gt; &amp;model2, const Transform3f &amp;tf2, const CollisionRequest &amp;request, CollisionResult &amp;result)</td></tr>
<tr class="memdesc:a6172ba73edad2b47579add3a42420f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for collision between two meshes, specialized for <a class="el" href="a00181.html" title="A class for rectangle sphere-swept bounding volume. ">RSS</a> type.  <a href="a00314.html#a6172ba73edad2b47579add3a42420f13">More...</a><br /></td></tr>
<tr class="separator:a6172ba73edad2b47579add3a42420f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445ae5e14b2677586c98dd9f8dae72d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00314.html#a445ae5e14b2677586c98dd9f8dae72d4">fcl::initialize</a> (MeshCollisionTraversalNodeOBBRSS &amp;node, const BVHModel&lt; OBBRSS &gt; &amp;model1, const Transform3f &amp;tf1, const BVHModel&lt; OBBRSS &gt; &amp;model2, const Transform3f &amp;tf2, const CollisionRequest &amp;request, CollisionResult &amp;result)</td></tr>
<tr class="memdesc:a445ae5e14b2677586c98dd9f8dae72d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for collision between two meshes, specialized for <a class="el" href="a00155.html" title="Class merging the OBB and RSS, can handle collision and distance simultaneously. ">OBBRSS</a> type.  <a href="a00314.html#a445ae5e14b2677586c98dd9f8dae72d4">More...</a><br /></td></tr>
<tr class="separator:a445ae5e14b2677586c98dd9f8dae72d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92845a6978810635a67e97669b60939"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00314.html#ac92845a6978810635a67e97669b60939">fcl::initialize</a> (MeshCollisionTraversalNodekIOS &amp;node, const BVHModel&lt; kIOS &gt; &amp;model1, const Transform3f &amp;tf1, const BVHModel&lt; kIOS &gt; &amp;model2, const Transform3f &amp;tf2, const CollisionRequest &amp;request, CollisionResult &amp;result)</td></tr>
<tr class="memdesc:ac92845a6978810635a67e97669b60939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for collision between two meshes, specialized for <a class="el" href="a00105.html" title="A class describing the kIOS collision structure, which is a set of spheres. ">kIOS</a> type.  <a href="a00314.html#ac92845a6978810635a67e97669b60939">More...</a><br /></td></tr>
<tr class="separator:ac92845a6978810635a67e97669b60939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7281e9516dfcf575e66dc2ec550ca9f9"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a7281e9516dfcf575e66dc2ec550ca9f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a7281e9516dfcf575e66dc2ec550ca9f9">fcl::initialize</a> (ShapeDistanceTraversalNode&lt; S1, S2, NarrowPhaseSolver &gt; &amp;node, const S1 &amp;shape1, const Transform3f &amp;tf1, const S2 &amp;shape2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, const DistanceRequest &amp;request, DistanceResult &amp;result)</td></tr>
<tr class="memdesc:a7281e9516dfcf575e66dc2ec550ca9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for distance between two geometric shapes.  <a href="a00314.html#a7281e9516dfcf575e66dc2ec550ca9f9">More...</a><br /></td></tr>
<tr class="separator:a7281e9516dfcf575e66dc2ec550ca9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d83108ae799336acb750074ac34875c"><td class="memTemplParams" colspan="2">template&lt;typename BV &gt; </td></tr>
<tr class="memitem:a6d83108ae799336acb750074ac34875c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a6d83108ae799336acb750074ac34875c">fcl::initialize</a> (MeshDistanceTraversalNode&lt; BV &gt; &amp;node, BVHModel&lt; BV &gt; &amp;model1, Transform3f &amp;tf1, BVHModel&lt; BV &gt; &amp;model2, Transform3f &amp;tf2, const DistanceRequest &amp;request, DistanceResult &amp;result, bool use_refit=false, bool refit_bottomup=false)</td></tr>
<tr class="memdesc:a6d83108ae799336acb750074ac34875c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for distance computation between two meshes, given the current transforms.  <a href="a00314.html#a6d83108ae799336acb750074ac34875c">More...</a><br /></td></tr>
<tr class="separator:a6d83108ae799336acb750074ac34875c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7281ec41a16bb015bec266409943bfb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00314.html#ae7281ec41a16bb015bec266409943bfb">fcl::initialize</a> (MeshDistanceTraversalNodeRSS &amp;node, const BVHModel&lt; RSS &gt; &amp;model1, const Transform3f &amp;tf1, const BVHModel&lt; RSS &gt; &amp;model2, const Transform3f &amp;tf2, const DistanceRequest &amp;request, DistanceResult &amp;result)</td></tr>
<tr class="memdesc:ae7281ec41a16bb015bec266409943bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for distance computation between two meshes, specialized for <a class="el" href="a00181.html" title="A class for rectangle sphere-swept bounding volume. ">RSS</a> type.  <a href="a00314.html#ae7281ec41a16bb015bec266409943bfb">More...</a><br /></td></tr>
<tr class="separator:ae7281ec41a16bb015bec266409943bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae6bf2e1917a5ae0d39c7222f4db17b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00314.html#a9ae6bf2e1917a5ae0d39c7222f4db17b">fcl::initialize</a> (MeshDistanceTraversalNodekIOS &amp;node, const BVHModel&lt; kIOS &gt; &amp;model1, const Transform3f &amp;tf1, const BVHModel&lt; kIOS &gt; &amp;model2, const Transform3f &amp;tf2, const DistanceRequest &amp;request, DistanceResult &amp;result)</td></tr>
<tr class="memdesc:a9ae6bf2e1917a5ae0d39c7222f4db17b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for distance computation between two meshes, specialized for <a class="el" href="a00105.html" title="A class describing the kIOS collision structure, which is a set of spheres. ">kIOS</a> type.  <a href="a00314.html#a9ae6bf2e1917a5ae0d39c7222f4db17b">More...</a><br /></td></tr>
<tr class="separator:a9ae6bf2e1917a5ae0d39c7222f4db17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e098b423058e0e340eb36e465d1a045"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00314.html#a7e098b423058e0e340eb36e465d1a045">fcl::initialize</a> (MeshDistanceTraversalNodeOBBRSS &amp;node, const BVHModel&lt; OBBRSS &gt; &amp;model1, const Transform3f &amp;tf1, const BVHModel&lt; OBBRSS &gt; &amp;model2, const Transform3f &amp;tf2, const DistanceRequest &amp;request, DistanceResult &amp;result)</td></tr>
<tr class="memdesc:a7e098b423058e0e340eb36e465d1a045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for distance computation between two meshes, specialized for <a class="el" href="a00155.html" title="Class merging the OBB and RSS, can handle collision and distance simultaneously. ">OBBRSS</a> type.  <a href="a00314.html#a7e098b423058e0e340eb36e465d1a045">More...</a><br /></td></tr>
<tr class="separator:a7e098b423058e0e340eb36e465d1a045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6081d28877bbc46eabf2c4e58fa4b69"><td class="memTemplParams" colspan="2">template&lt;typename BV , typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:ae6081d28877bbc46eabf2c4e58fa4b69"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#ae6081d28877bbc46eabf2c4e58fa4b69">fcl::initialize</a> (MeshShapeDistanceTraversalNode&lt; BV, S, NarrowPhaseSolver &gt; &amp;node, BVHModel&lt; BV &gt; &amp;model1, Transform3f &amp;tf1, const S &amp;model2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, const DistanceRequest &amp;request, DistanceResult &amp;result, bool use_refit=false, bool refit_bottomup=false)</td></tr>
<tr class="memdesc:ae6081d28877bbc46eabf2c4e58fa4b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for distance computation between one mesh and one shape, given the current transforms.  <a href="a00314.html#ae6081d28877bbc46eabf2c4e58fa4b69">More...</a><br /></td></tr>
<tr class="separator:ae6081d28877bbc46eabf2c4e58fa4b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3927dc6c1e9c7b490e7ba408f0457d74"><td class="memTemplParams" colspan="2">template&lt;typename S , typename BV , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a3927dc6c1e9c7b490e7ba408f0457d74"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a3927dc6c1e9c7b490e7ba408f0457d74">fcl::initialize</a> (ShapeMeshDistanceTraversalNode&lt; S, BV, NarrowPhaseSolver &gt; &amp;node, const S &amp;model1, const Transform3f &amp;tf1, BVHModel&lt; BV &gt; &amp;model2, Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, const DistanceRequest &amp;request, DistanceResult &amp;result, bool use_refit=false, bool refit_bottomup=false)</td></tr>
<tr class="memdesc:a3927dc6c1e9c7b490e7ba408f0457d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for distance computation between one shape and one mesh, given the current transforms.  <a href="a00314.html#a3927dc6c1e9c7b490e7ba408f0457d74">More...</a><br /></td></tr>
<tr class="separator:a3927dc6c1e9c7b490e7ba408f0457d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565a813b61a2cc9625c945ea5cd27fcc"><td class="memTemplParams" colspan="2">template&lt;typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a565a813b61a2cc9625c945ea5cd27fcc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a565a813b61a2cc9625c945ea5cd27fcc">fcl::initialize</a> (MeshShapeDistanceTraversalNodeRSS&lt; S, NarrowPhaseSolver &gt; &amp;node, const BVHModel&lt; RSS &gt; &amp;model1, const Transform3f &amp;tf1, const S &amp;model2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, const DistanceRequest &amp;request, DistanceResult &amp;result)</td></tr>
<tr class="memdesc:a565a813b61a2cc9625c945ea5cd27fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for distance computation between one mesh and one shape, specialized for <a class="el" href="a00181.html" title="A class for rectangle sphere-swept bounding volume. ">RSS</a> type.  <a href="a00314.html#a565a813b61a2cc9625c945ea5cd27fcc">More...</a><br /></td></tr>
<tr class="separator:a565a813b61a2cc9625c945ea5cd27fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c79be90859fd861e8658eac375c4c0b"><td class="memTemplParams" colspan="2">template&lt;typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a2c79be90859fd861e8658eac375c4c0b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a2c79be90859fd861e8658eac375c4c0b">fcl::initialize</a> (MeshShapeDistanceTraversalNodekIOS&lt; S, NarrowPhaseSolver &gt; &amp;node, const BVHModel&lt; kIOS &gt; &amp;model1, const Transform3f &amp;tf1, const S &amp;model2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, const DistanceRequest &amp;request, DistanceResult &amp;result)</td></tr>
<tr class="memdesc:a2c79be90859fd861e8658eac375c4c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for distance computation between one mesh and one shape, specialized for <a class="el" href="a00105.html" title="A class describing the kIOS collision structure, which is a set of spheres. ">kIOS</a> type.  <a href="a00314.html#a2c79be90859fd861e8658eac375c4c0b">More...</a><br /></td></tr>
<tr class="separator:a2c79be90859fd861e8658eac375c4c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cdb1867ff01f78f183258410ad6a18"><td class="memTemplParams" colspan="2">template&lt;typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:ac1cdb1867ff01f78f183258410ad6a18"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#ac1cdb1867ff01f78f183258410ad6a18">fcl::initialize</a> (MeshShapeDistanceTraversalNodeOBBRSS&lt; S, NarrowPhaseSolver &gt; &amp;node, const BVHModel&lt; OBBRSS &gt; &amp;model1, const Transform3f &amp;tf1, const S &amp;model2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, const DistanceRequest &amp;request, DistanceResult &amp;result)</td></tr>
<tr class="memdesc:ac1cdb1867ff01f78f183258410ad6a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for distance computation between one mesh and one shape, specialized for <a class="el" href="a00155.html" title="Class merging the OBB and RSS, can handle collision and distance simultaneously. ">OBBRSS</a> type.  <a href="a00314.html#ac1cdb1867ff01f78f183258410ad6a18">More...</a><br /></td></tr>
<tr class="separator:ac1cdb1867ff01f78f183258410ad6a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a2102230569411b26298d24486f83d"><td class="memTemplParams" colspan="2">template&lt;typename S , typename BV , typename NarrowPhaseSolver , template&lt; typename, typename &gt; class OrientedNode&gt; </td></tr>
<tr class="memitem:a06a2102230569411b26298d24486f83d"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00362.html#a06a2102230569411b26298d24486f83d">fcl::details::setupShapeMeshDistanceOrientedNode</a> (OrientedNode&lt; S, NarrowPhaseSolver &gt; &amp;node, const S &amp;model1, const Transform3f &amp;tf1, const BVHModel&lt; BV &gt; &amp;model2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, const DistanceRequest &amp;request, DistanceResult &amp;result)</td></tr>
<tr class="separator:a06a2102230569411b26298d24486f83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5a356ca3b158cd12d0a7fb48a36ec7"><td class="memTemplParams" colspan="2">template&lt;typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a5d5a356ca3b158cd12d0a7fb48a36ec7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a5d5a356ca3b158cd12d0a7fb48a36ec7">fcl::initialize</a> (ShapeMeshDistanceTraversalNodeRSS&lt; S, NarrowPhaseSolver &gt; &amp;node, const S &amp;model1, const Transform3f &amp;tf1, const BVHModel&lt; RSS &gt; &amp;model2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, const DistanceRequest &amp;request, DistanceResult &amp;result)</td></tr>
<tr class="memdesc:a5d5a356ca3b158cd12d0a7fb48a36ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for distance computation between one shape and one mesh, specialized for <a class="el" href="a00181.html" title="A class for rectangle sphere-swept bounding volume. ">RSS</a> type.  <a href="a00314.html#a5d5a356ca3b158cd12d0a7fb48a36ec7">More...</a><br /></td></tr>
<tr class="separator:a5d5a356ca3b158cd12d0a7fb48a36ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6397a9976cdeaaaf862fcbd3be7a6710"><td class="memTemplParams" colspan="2">template&lt;typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a6397a9976cdeaaaf862fcbd3be7a6710"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a6397a9976cdeaaaf862fcbd3be7a6710">fcl::initialize</a> (ShapeMeshDistanceTraversalNodekIOS&lt; S, NarrowPhaseSolver &gt; &amp;node, const S &amp;model1, const Transform3f &amp;tf1, const BVHModel&lt; kIOS &gt; &amp;model2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, const DistanceRequest &amp;request, DistanceResult &amp;result)</td></tr>
<tr class="memdesc:a6397a9976cdeaaaf862fcbd3be7a6710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for distance computation between one shape and one mesh, specialized for <a class="el" href="a00105.html" title="A class describing the kIOS collision structure, which is a set of spheres. ">kIOS</a> type.  <a href="a00314.html#a6397a9976cdeaaaf862fcbd3be7a6710">More...</a><br /></td></tr>
<tr class="separator:a6397a9976cdeaaaf862fcbd3be7a6710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284c3c2b87a088edd29880eb01eac192"><td class="memTemplParams" colspan="2">template&lt;typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a284c3c2b87a088edd29880eb01eac192"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a284c3c2b87a088edd29880eb01eac192">fcl::initialize</a> (ShapeMeshDistanceTraversalNodeOBBRSS&lt; S, NarrowPhaseSolver &gt; &amp;node, const S &amp;model1, const Transform3f &amp;tf1, const BVHModel&lt; OBBRSS &gt; &amp;model2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, const DistanceRequest &amp;request, DistanceResult &amp;result)</td></tr>
<tr class="memdesc:a284c3c2b87a088edd29880eb01eac192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for distance computation between one shape and one mesh, specialized for <a class="el" href="a00155.html" title="Class merging the OBB and RSS, can handle collision and distance simultaneously. ">OBBRSS</a> type.  <a href="a00314.html#a284c3c2b87a088edd29880eb01eac192">More...</a><br /></td></tr>
<tr class="separator:a284c3c2b87a088edd29880eb01eac192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2be0ab29509878e631b7a133440eb0"><td class="memTemplParams" colspan="2">template&lt;typename BV &gt; </td></tr>
<tr class="memitem:a0d2be0ab29509878e631b7a133440eb0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a0d2be0ab29509878e631b7a133440eb0">fcl::initialize</a> (MeshContinuousCollisionTraversalNode&lt; BV &gt; &amp;node, const BVHModel&lt; BV &gt; &amp;model1, const Transform3f &amp;tf1, const BVHModel&lt; BV &gt; &amp;model2, const Transform3f &amp;tf2, const CollisionRequest &amp;request)</td></tr>
<tr class="memdesc:a0d2be0ab29509878e631b7a133440eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for continuous collision detection between two meshes.  <a href="a00314.html#a0d2be0ab29509878e631b7a133440eb0">More...</a><br /></td></tr>
<tr class="separator:a0d2be0ab29509878e631b7a133440eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305d357f88e8c3b8225a9788da41a6db"><td class="memTemplParams" colspan="2">template&lt;typename BV &gt; </td></tr>
<tr class="memitem:a305d357f88e8c3b8225a9788da41a6db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a305d357f88e8c3b8225a9788da41a6db">fcl::initialize</a> (MeshConservativeAdvancementTraversalNode&lt; BV &gt; &amp;node, BVHModel&lt; BV &gt; &amp;model1, const Transform3f &amp;tf1, BVHModel&lt; BV &gt; &amp;model2, const Transform3f &amp;tf2, FCL_REAL w=1, bool use_refit=false, bool refit_bottomup=false)</td></tr>
<tr class="memdesc:a305d357f88e8c3b8225a9788da41a6db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for conservative advancement computation between two meshes, given the current transforms.  <a href="a00314.html#a305d357f88e8c3b8225a9788da41a6db">More...</a><br /></td></tr>
<tr class="separator:a305d357f88e8c3b8225a9788da41a6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbd027912820f1ee7bdbff2cec392cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00314.html#abbbd027912820f1ee7bdbff2cec392cd">fcl::initialize</a> (MeshConservativeAdvancementTraversalNodeRSS &amp;node, const BVHModel&lt; RSS &gt; &amp;model1, const Transform3f &amp;tf1, const BVHModel&lt; RSS &gt; &amp;model2, const Transform3f &amp;tf2, FCL_REAL w=1)</td></tr>
<tr class="memdesc:abbbd027912820f1ee7bdbff2cec392cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize traversal node for conservative advancement computation between two meshes, given the current transforms, specialized for <a class="el" href="a00181.html" title="A class for rectangle sphere-swept bounding volume. ">RSS</a>.  <a href="a00314.html#abbbd027912820f1ee7bdbff2cec392cd">More...</a><br /></td></tr>
<tr class="separator:abbbd027912820f1ee7bdbff2cec392cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b4586038f9db4d294b2d42c3a03d86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00314.html#a30b4586038f9db4d294b2d42c3a03d86">fcl::initialize</a> (MeshConservativeAdvancementTraversalNodeOBBRSS &amp;node, const BVHModel&lt; OBBRSS &gt; &amp;model1, const Transform3f &amp;tf1, const BVHModel&lt; OBBRSS &gt; &amp;model2, const Transform3f &amp;tf2, FCL_REAL w=1)</td></tr>
<tr class="separator:a30b4586038f9db4d294b2d42c3a03d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96aa3d9216c77da07046d67fddccabf7"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a96aa3d9216c77da07046d67fddccabf7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a96aa3d9216c77da07046d67fddccabf7">fcl::initialize</a> (ShapeConservativeAdvancementTraversalNode&lt; S1, S2, NarrowPhaseSolver &gt; &amp;node, const S1 &amp;shape1, const Transform3f &amp;tf1, const S2 &amp;shape2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver)</td></tr>
<tr class="separator:a96aa3d9216c77da07046d67fddccabf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694be7695ffd564038f61b09be48d1f5"><td class="memTemplParams" colspan="2">template&lt;typename BV , typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a694be7695ffd564038f61b09be48d1f5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a694be7695ffd564038f61b09be48d1f5">fcl::initialize</a> (MeshShapeConservativeAdvancementTraversalNode&lt; BV, S, NarrowPhaseSolver &gt; &amp;node, BVHModel&lt; BV &gt; &amp;model1, const Transform3f &amp;tf1, const S &amp;model2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, FCL_REAL w=1, bool use_refit=false, bool refit_bottomup=false)</td></tr>
<tr class="separator:a694be7695ffd564038f61b09be48d1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a3fdd8186ea3c140b5650fe642ca9c"><td class="memTemplParams" colspan="2">template&lt;typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:ae8a3fdd8186ea3c140b5650fe642ca9c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#ae8a3fdd8186ea3c140b5650fe642ca9c">fcl::initialize</a> (MeshShapeConservativeAdvancementTraversalNodeRSS&lt; S, NarrowPhaseSolver &gt; &amp;node, const BVHModel&lt; RSS &gt; &amp;model1, const Transform3f &amp;tf1, const S &amp;model2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, FCL_REAL w=1)</td></tr>
<tr class="separator:ae8a3fdd8186ea3c140b5650fe642ca9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cecee41fb90fc4e4571f4b7fae31ccc"><td class="memTemplParams" colspan="2">template&lt;typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a5cecee41fb90fc4e4571f4b7fae31ccc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a5cecee41fb90fc4e4571f4b7fae31ccc">fcl::initialize</a> (MeshShapeConservativeAdvancementTraversalNodeOBBRSS&lt; S, NarrowPhaseSolver &gt; &amp;node, const BVHModel&lt; OBBRSS &gt; &amp;model1, const Transform3f &amp;tf1, const S &amp;model2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, FCL_REAL w=1)</td></tr>
<tr class="separator:a5cecee41fb90fc4e4571f4b7fae31ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c756df9480d5e756902ba623900f58"><td class="memTemplParams" colspan="2">template&lt;typename S , typename BV , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a82c756df9480d5e756902ba623900f58"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a82c756df9480d5e756902ba623900f58">fcl::initialize</a> (ShapeMeshConservativeAdvancementTraversalNode&lt; S, BV, NarrowPhaseSolver &gt; &amp;node, const S &amp;model1, const Transform3f &amp;tf1, BVHModel&lt; BV &gt; &amp;model2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, FCL_REAL w=1, bool use_refit=false, bool refit_bottomup=false)</td></tr>
<tr class="separator:a82c756df9480d5e756902ba623900f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855700003a10bb817a1a1fca63c67ce1"><td class="memTemplParams" colspan="2">template&lt;typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:a855700003a10bb817a1a1fca63c67ce1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#a855700003a10bb817a1a1fca63c67ce1">fcl::initialize</a> (ShapeMeshConservativeAdvancementTraversalNodeRSS&lt; S, NarrowPhaseSolver &gt; &amp;node, const S &amp;model1, const Transform3f &amp;tf1, const BVHModel&lt; RSS &gt; &amp;model2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, FCL_REAL w=1)</td></tr>
<tr class="separator:a855700003a10bb817a1a1fca63c67ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7007887b0110ee81983b34de79f7ca4"><td class="memTemplParams" colspan="2">template&lt;typename S , typename NarrowPhaseSolver &gt; </td></tr>
<tr class="memitem:ac7007887b0110ee81983b34de79f7ca4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00314.html#ac7007887b0110ee81983b34de79f7ca4">fcl::initialize</a> (ShapeMeshConservativeAdvancementTraversalNodeOBBRSS&lt; S, NarrowPhaseSolver &gt; &amp;node, const S &amp;model1, const Transform3f &amp;tf1, const BVHModel&lt; OBBRSS &gt; &amp;model2, const Transform3f &amp;tf2, const NarrowPhaseSolver *nsolver, FCL_REAL w=1)</td></tr>
<tr class="separator:ac7007887b0110ee81983b34de79f7ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 13 2016 15:32:47 for hpp-fcl by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
